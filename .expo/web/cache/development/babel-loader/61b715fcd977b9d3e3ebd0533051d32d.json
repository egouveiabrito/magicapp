{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _NavigationActions = _interopRequireDefault(require(\"../NavigationActions\"));\n\nvar _StackActions = _interopRequireDefault(require(\"./StackActions\"));\n\nvar _createConfigGetter = _interopRequireDefault(require(\"./createConfigGetter\"));\n\nvar _getScreenForRouteName = _interopRequireDefault(require(\"./getScreenForRouteName\"));\n\nvar _StateUtils = _interopRequireDefault(require(\"../StateUtils\"));\n\nvar _validateRouteConfigMap = _interopRequireDefault(require(\"./validateRouteConfigMap\"));\n\nvar _invariant = _interopRequireDefault(require(\"../utils/invariant\"));\n\nvar _KeyGenerator = require(\"./KeyGenerator\");\n\nvar _pathUtils = require(\"./pathUtils\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction behavesLikePushAction(action) {\n  return action.type === _NavigationActions.default.NAVIGATE || action.type === _StackActions.default.PUSH;\n}\n\nvar defaultActionCreators = function defaultActionCreators(route, navStateKey) {\n  return {};\n};\n\nfunction isResetToRootStack(action) {\n  return action.type === _StackActions.default.RESET && action.key === null;\n}\n\nvar _default = function _default(routeConfigs) {\n  var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _validateRouteConfigMap.default)(routeConfigs);\n  var childRouters = {};\n  var routeNames = Object.keys(routeConfigs);\n  routeNames.forEach(function (routeName) {\n    var screen = (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n\n    if (screen && screen.router) {\n      childRouters[routeName] = screen.router;\n    } else {\n      childRouters[routeName] = null;\n    }\n  });\n  var initialRouteParams = stackConfig.initialRouteParams;\n  var getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;\n  var initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  var initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    var route = {};\n    var childRouter = childRouters[action.routeName];\n\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      var childState = {};\n\n      if (childRouter !== null) {\n        var childAction = action.action || _NavigationActions.default.init({\n          params: action.params\n        });\n\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [_objectSpread({\n          params: action.params\n        }, childState, {\n          key: action.key || (0, _KeyGenerator.generateKey)(),\n          routeName: action.routeName\n        })]\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(_NavigationActions.default.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n\n    var params = (route.params || action.params || initialRouteParams) && _objectSpread({}, route.params || {}, {}, action.params || {}, {}, initialRouteParams || {});\n\n    var initialRouteKey = stackConfig.initialRouteKey;\n    route = _objectSpread({}, route, {}, params ? {\n      params: params\n    } : {}, {\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || (0, _KeyGenerator.generateKey)()\n    });\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n\n  var _createPathParser = (0, _pathUtils.createPathParser)(childRouters, routeConfigs, stackConfig),\n      getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n      _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n\n  return {\n    childRouters: childRouters,\n    getComponentForState: function getComponentForState(state) {\n      var activeChildRoute = state.routes[state.index];\n      var routeName = activeChildRoute.routeName;\n\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n\n      return (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n    },\n    getActionCreators: function getActionCreators(route, navStateKey) {\n      return _objectSpread({}, getCustomActionCreators(route, navStateKey), {\n        pop: function pop(n, params) {\n          return _StackActions.default.pop(_objectSpread({\n            n: n\n          }, params));\n        },\n        popToTop: function popToTop(params) {\n          return _StackActions.default.popToTop(params);\n        },\n        push: function push(routeName, params, action) {\n          return _StackActions.default.push({\n            routeName: routeName,\n            params: params,\n            action: action\n          });\n        },\n        replace: function replace(replaceWith, params, action, newKey) {\n          if (typeof replaceWith === 'string') {\n            return _StackActions.default.replace({\n              routeName: replaceWith,\n              params: params,\n              action: action,\n              key: route.key,\n              newKey: newKey\n            });\n          }\n\n          (0, _invariant.default)(typeof replaceWith === 'object', 'Must replaceWith an object or a string');\n          (0, _invariant.default)(params == null, 'Params must not be provided to .replace() when specifying an object');\n          (0, _invariant.default)(action == null, 'Child action must not be provided to .replace() when specifying an object');\n          (0, _invariant.default)(newKey == null, 'Child action must not be provided to .replace() when specifying an object');\n          return _StackActions.default.replace(replaceWith);\n        },\n        reset: function reset(actions, index) {\n          return _StackActions.default.reset({\n            actions: actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey\n          });\n        },\n        dismiss: function dismiss() {\n          return _NavigationActions.default.back({\n            key: navStateKey\n          });\n        }\n      });\n    },\n    getStateForAction: function getStateForAction(action, state) {\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      var activeChildRoute = state.routes[state.index];\n\n      if (!isResetToRootStack(action) && action.type !== _NavigationActions.default.NAVIGATE) {\n        var activeChildRouter = childRouters[activeChildRoute.routeName];\n\n        if (activeChildRouter) {\n          var route = activeChildRouter.getStateForAction(action, activeChildRoute);\n\n          if (route !== null && route !== activeChildRoute) {\n            return _StateUtils.default.replaceAt(state, activeChildRoute.key, route, action.type === _NavigationActions.default.SET_PARAMS);\n          }\n        }\n      } else if (action.type === _NavigationActions.default.NAVIGATE) {\n        for (var _iterator = state.routes.slice().reverse(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var _childRoute = _ref;\n          var _childRouter = childRouters[_childRoute.routeName];\n\n          var _childAction = action.routeName === _childRoute.routeName && action.action ? action.action : action;\n\n          if (_childRouter) {\n            var nextRouteState = _childRouter.getStateForAction(_childAction, _childRoute);\n\n            if (nextRouteState === null || nextRouteState !== _childRoute) {\n              var newState = _StateUtils.default.replaceAndPrune(state, nextRouteState ? nextRouteState.key : _childRoute.key, nextRouteState ? nextRouteState : _childRoute);\n\n              return _objectSpread({}, newState, {\n                isTransitioning: state.index !== newState.index ? action.immediate !== true : state.isTransitioning\n              });\n            }\n          }\n        }\n      }\n\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {\n        var _childRouter2 = childRouters[action.routeName];\n\n        var _route;\n\n        (0, _invariant.default)(action.type !== _StackActions.default.PUSH || action.key == null, 'StackRouter does not support key on the push action');\n        var lastRouteIndex = state.routes.findIndex(function (r) {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        if (action.type !== _StackActions.default.PUSH && lastRouteIndex !== -1) {\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          var routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          if (action.params) {\n            var _route2 = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = _objectSpread({}, _route2, {\n              params: _objectSpread({}, _route2.params, {}, action.params)\n            });\n          }\n\n          return _objectSpread({}, state, {\n            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,\n            index: lastRouteIndex,\n            routes: routes\n          });\n        }\n\n        if (_childRouter2) {\n          var _childAction2 = action.action || _NavigationActions.default.init({\n            params: action.params\n          });\n\n          _route = _objectSpread({\n            params: action.params\n          }, _childRouter2.getStateForAction(_childAction2), {\n            routeName: action.routeName,\n            key: action.key || (0, _KeyGenerator.generateKey)()\n          });\n        } else {\n          _route = {\n            params: action.params,\n            routeName: action.routeName,\n            key: action.key || (0, _KeyGenerator.generateKey)()\n          };\n        }\n\n        return _objectSpread({}, _StateUtils.default.push(state, _route), {\n          isTransitioning: action.immediate !== true\n        });\n      } else if (action.type === _StackActions.default.PUSH && childRouters[action.routeName] === undefined) {\n        return state;\n      }\n\n      if (behavesLikePushAction(action)) {\n        var childRouterNames = Object.keys(childRouters);\n\n        for (var i = 0; i < childRouterNames.length; i++) {\n          var childRouterName = childRouterNames[i];\n          var _childRouter3 = childRouters[childRouterName];\n\n          if (_childRouter3) {\n            var initChildRoute = _childRouter3.getStateForAction(_NavigationActions.default.init());\n\n            var navigatedChildRoute = _childRouter3.getStateForAction(action, initChildRoute);\n\n            var routeToPush = null;\n\n            if (navigatedChildRoute === null) {\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              routeToPush = navigatedChildRoute;\n            }\n\n            if (routeToPush) {\n              var _route3 = _objectSpread({}, routeToPush, {\n                routeName: childRouterName,\n                key: action.key || (0, _KeyGenerator.generateKey)()\n              });\n\n              return _objectSpread({}, _StateUtils.default.push(state, _route3), {\n                isTransitioning: action.immediate !== true\n              });\n            }\n          }\n        }\n      }\n\n      if (action.type === _StackActions.default.POP_TO_TOP) {\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        if (state.index > 0) {\n          return _objectSpread({}, state, {\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          });\n        }\n\n        return state;\n      }\n\n      if (action.type === _StackActions.default.REPLACE) {\n        var routeIndex;\n\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(function (r) {\n            return r.key === action.key;\n          });\n        }\n\n        if (routeIndex !== -1) {\n          var _childRouter4 = childRouters[action.routeName];\n          var childState = {};\n\n          if (_childRouter4) {\n            var _childAction3 = action.action || _NavigationActions.default.init({\n              params: action.params\n            });\n\n            childState = _childRouter4.getStateForAction(_childAction3);\n          }\n\n          var _routes = (0, _toConsumableArray2.default)(state.routes);\n\n          _routes[routeIndex] = _objectSpread({\n            params: action.params\n          }, childState, {\n            routeName: action.routeName,\n            key: action.newKey || (0, _KeyGenerator.generateKey)()\n          });\n          return _objectSpread({}, state, {\n            routes: _routes\n          });\n        }\n      }\n\n      if (action.type === _StackActions.default.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && state.isTransitioning) {\n        return _objectSpread({}, state, {\n          isTransitioning: false\n        });\n      }\n\n      if (action.type === _NavigationActions.default.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var params = _objectSpread({}, lastRoute.params, {}, action.params);\n\n          var _routes2 = (0, _toConsumableArray2.default)(state.routes);\n\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: params\n          });\n          return _objectSpread({}, state, {\n            routes: _routes2\n          });\n        }\n      }\n\n      if (action.type === _StackActions.default.RESET) {\n        if (action.key != null && action.key != state.key) {\n          return state;\n        }\n\n        var newStackActions = action.actions;\n        return _objectSpread({}, state, {\n          routes: newStackActions.map(function (newStackAction) {\n            var router = childRouters[newStackAction.routeName];\n            var childState = {};\n\n            if (router) {\n              var _childAction4 = newStackAction.action || _NavigationActions.default.init({\n                params: newStackAction.params\n              });\n\n              childState = router.getStateForAction(_childAction4);\n            }\n\n            return _objectSpread({\n              params: newStackAction.params\n            }, childState, {\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || (0, _KeyGenerator.generateKey)()\n            });\n          }),\n          index: action.index\n        });\n      }\n\n      if (action.type === _NavigationActions.default.BACK || action.type === _StackActions.default.POP) {\n        var _key = action.key,\n            n = action.n,\n            immediate = action.immediate;\n        var backRouteIndex = state.index;\n\n        if (action.type === _StackActions.default.POP && n != null) {\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (_key) {\n          var backRoute = state.routes.find(function (route) {\n            return route.key === _key;\n          });\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return _objectSpread({}, state, {\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true\n          });\n        }\n      }\n\n      var keyIndex = action.key ? _StateUtils.default.indexOf(state, action.key) : -1;\n\n      for (var _iterator2 = state.routes.slice().reverse(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var _childRoute3 = _ref2;\n\n        if (_childRoute3.key === activeChildRoute.key) {\n          continue;\n        }\n\n        if (keyIndex >= 0 && _childRoute3.key !== action.key) {\n          continue;\n        }\n\n        var _childRouter6 = childRouters[_childRoute3.routeName];\n\n        if (_childRouter6) {\n          var _route4 = _childRouter6.getStateForAction(action, _childRoute3);\n\n          if (_route4 === null) {\n            return state;\n          } else if (_route4 && _route4 !== _childRoute3) {\n            return _StateUtils.default.replaceAt(state, _childRoute3.key, _route4, action.type === _NavigationActions.default.SET_PARAMS || action.type === _StackActions.default.COMPLETE_TRANSITION);\n          }\n        }\n      }\n\n      return state;\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: (0, _createConfigGetter.default)(routeConfigs, stackConfig.navigationOptions)\n  };\n};\n\nexports.default = _default;","map":{"version":3,"sources":["C:/React/magic/node_modules/react-navigation/src/routers/StackRouter.js"],"names":["behavesLikePushAction","action","type","NavigationActions","NAVIGATE","StackActions","PUSH","defaultActionCreators","route","navStateKey","isResetToRootStack","RESET","key","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","getInitialState","childRouter","undefined","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","navigate","initialRouteKey","getPathAndParamsForRoute","getActionForPathAndParams","getComponentForState","state","activeChildRoute","getComponentForRouteName","getActionCreators","pop","n","popToTop","push","replace","replaceWith","newKey","reset","actions","length","dismiss","back","activeChildRouter","StateUtils","replaceAt","SET_PARAMS","slice","reverse","childRoute","nextRouteState","newState","replaceAndPrune","immediate","lastRouteIndex","findIndex","r","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","COMPLETE_TRANSITION","lastRoute","find","indexOf","newStackActions","map","newStackAction","BACK","POP","backRouteIndex","Math","max","backRoute","keyIndex","getPathAndParamsForState","path","getScreenOptions","navigationOptions"],"mappings":"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","sourcesContent":["import NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = (route, navStateKey) => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (route.params || action.params || initialRouteParams) && {\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle explicit push navigation action. This must happen after the\n      // focused child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          const childAction =\n            action.action || NavigationActions.init({ params: action.params });\n          route = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          route = {\n            params: action.params,\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({ params: action.params });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({ params: newStackAction.params });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: newStackAction.params,\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action or complete transition action,\n              // because people don't expect these actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS ||\n                action.type === StackActions.COMPLETE_TRANSITION\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.navigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"script"}